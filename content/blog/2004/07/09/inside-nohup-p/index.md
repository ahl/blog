---
title: "Inside nohup -p"
date: "2004-07-09"
categories:
  - "opensolaris"
permalink: /2004/07/09/inside-nohup-p/
---

I always thought it was cool, but I was surprised by the amount of [interest](http://www.evilrob.org/journal/archives/000078.html) expressed for my [recent post](http://dtrace.org/blogs/ahl/old_school_solaris_and_solaris) on `nohup -p`. There was even a comment asking how `nohup` manages the trick of redirecting the output of a running process. I'll describe in some detail now `nohup -p` works.

First, a little background material: [Eric Schrock](http://blogs.sun.com/eschrock) recently had a [nice post](http://blogs.sun.com/roller/page/eschrock/20040625#the_power_of_proc) about the history of the `/proc` file system; `nohup` makes use of Solaris's `/proc` and the agent LWP in particular which Eric also [described in detail](http://blogs.sun.com/roller/page/eschrock/20040627#the_secret_agent_lwp). All of the `/proc` and agent LWP tricks I describe are documented in the [proc(4) man page](http://docs.sun.com/db/doc/816-5174/6mbb98ui4?a=view).

Historically, `nohup` invoked a process with SIGHUP and SIGQUIT masked and the output directed to a file called nohup.out. When you run a command inside a terminal there can be two problems: all the output is just recorded to that terminal, and if the terminal goes away the command will receive a SIGHUP, killing it by default. You use `nohup` to both capture the output in a file and protect the process against the terminal being killed (e.g. if your `telnet` connection drops).

To "nohup" a running process we both need to mask SIGHUP and SIGQUIT and redirect the output to the file nohup.out. The agent LWP makes this possible. First we create the agent LWP and have it execute the [sigaction(2)](http://docs.sun.com/db/doc/816-5167/6mbb2jais?a=view) system call to mask of SIGHUP and SIGQUIT. Next we need to redirect any output intended for the controling terminal to the file nohup.out. This is easy in principle: we find all file descriptors open to the controlling terminal, have the agent LWP close them, and then reopen them to the file nohup.out. The problem is that other LWPs (threads) in the process might be using (e.g. with the [read(2)](http://docs.sun.com/db/doc/816-5167/6mbb2jai6?a=view) or [write(2)](http://docs.sun.com/db/doc/816-5167/6mbb2jaju?a=view) system calls) those file descriptors and the [close(2)](http://docs.sun.com/db/doc/816-5167/6mbb2jaff?a=view) will actually block until those operations have completed. When the agent LWP is present in a process, none of the other LWPs can run so none of the outstanding operations on those file descriptors can complete so the process would deadlock. Note that we can work ourselves out of the deadlock by removing the agent LWP, but we still have a problem.

The solution is this: with all LWPs in the process stopped, we identify all the file descriptors that we'll need to close and reopen, and then abort (using the PRSABORT flag listed in the proc(4) man page) those sytem calls. Once all outstanding operations have been aborted (or successfully completed) we know that there won't be any possibility of deadlocking the process. The agent LWP executes the [open(2)](http://docs.sun.com/db/doc/816-5167/6mbb2jahi?a=view) system call to open the nohup.out file and then has the victim process [dup2(3C)](http://docs.sun.com/db/doc/816-5168/6mbb3hr2i?a=view) that file descriptor over the ones open to the process's controlling terminal (implicitly closing them). Actually, dup2(3C) is a library call so we have the agent LWP execute a [fcntl(2)](http://docs.sun.com/db/doc/816-5167/6mbb2jafn?q=sigaction&a=view) system call with the F\_DUP2FD command.

Whew. Complicated to be sure, but at the end of it all, our precious process is protected against SIGHUP and SIGQUIT and through our arduous labors, output once intended for the terminal is now safely kept in a file. If this made sense or was even useful, I'd love to hear it...
